<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Functional programming</title><script defer="defer" src="main.js"></script></head><body><main><div class="content-wrapper"><section><ol><li><p>Написать функцию maxItemAssociation(), получающую исторические данные покупок пользователей и возвращающую максимальный список рекомендаций.</p><p>Входные данные - массив исторических покупок пользователей [["a", "b"], ["a", "c"], ["d", "e"]]. То есть</p><p>пользователь 1 купил "a" и "b". Пользователь 2 купил продукты "a", "c". Пользователь 3 купил</p><p>продукты "d", "e".</p><p>Надо найти максимальную группу рекомендаций. Группа рекомендаций - это продукты, которые был</p><p>куплены другими пользователями при условии, если они пересекаются с исходным списком.</p><p>Если количество рекомендаций в группах одинаковое - вернуть первую группу, из отсортированных в</p><p>лексикографическом порядке.</p><p>Решение:</p><p>Группа рекомендаций 1 - ["a", "b", "c"]. Покупка "a" содержится в списке 2, поэтому весь список 2 может</p><p>быть добавлен в рекомендации.</p><p>Группа рекомендаций 2 - ["d", "e"].</p><p>Ответ: ["a", "b", "c"].</p><p>Пример 2:</p><p>Входные данные: [</p><p>["q", "w", 'a'],</p><p>["a", "b"],</p><p>["a", "c"],</p><p>["q", "e"],</p><p>["q", "r"]</p><p>]</p><p>Ответ ["a", "b", "c", "e", "q", "r", "w"] - это максимальная по пересечениям группа. Можно видеть, что первый массив пересекается со</p><p>всеми остальными, и потому результат является всем множеством значений.</p></li></ol></section></div></main></body></html>